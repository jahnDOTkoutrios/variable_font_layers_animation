<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="favicon.png">
    <title>SVG Font Typing</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @font-face {
            font-family: 'G2ErikaMono';
            src: url('G2-Erika-Mono.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        body {
            font-family: 'G2ErikaMono', monospace;
            max-width: 100%;
            margin: 0;
            padding: 10px;
            background-color: #f8f9fa;
            transition: background-color 0.3s ease;
            font-size: 12px;
            font-weight: normal;
            box-sizing: border-box;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            text-transform: uppercase;
        }

        body.dark {
            background-color: #1a1a1a;
        }

        .container {
            width: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #textInput {
            width: 100%;
            padding: 12px;
            font-size: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            background-color: white;
            font-family: 'G2ErikaMono', monospace;
            transition: all 0.3s ease;
            box-sizing: border-box;
            outline: none;
            font-weight: normal;
            text-transform: uppercase;
        }

        body.dark #textInput {
            background-color: #2a2a2a;
            color: #fff;
        }

        #textInput2 {
            width: 100%;
            padding: 12px;
            font-size: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            background-color: white;
            font-family: 'G2ErikaMono', monospace;
            transition: all 0.3s ease;
            box-sizing: border-box;
            outline: none;
            font-weight: normal;
            text-transform: uppercase;
        }

        body.dark #textInput2 {
            background-color: #2a2a2a;
            color: #fff;
        }

        #svgContainer {
            width: 100%;
            flex: 1;
            border: none;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: white;
            transition: all 0.3s ease;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        body.dark #svgContainer {
            background-color: #2a2a2a;
        }

        .controls {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 10px;
            padding: 0;
            background-color: transparent;
            border-radius: 0;
            transition: all 0.3s ease;
            box-sizing: border-box;
            border: none;
            position: relative;
        }

        body.dark .controls {
            background-color: transparent;
        }

        .control-section {
            background-color: white;
            border-radius: 12px;
            padding: 16px;
            margin: 0;
            border: none;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        body.dark .control-section {
            background-color: #2a2a2a;
        }

        .control-section h3 {
            margin: 0 0 16px 0;
            font-size: 12px;
            color: #666;
            padding-bottom: 0;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        body.dark .control-section h3 {
            color: #999;
            font-weight: normal;
        }

        .control-group {
            display: grid;
            grid-template-columns: 50px 1fr;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .control-group label {
            font-size: 12px;
            color: #666;
            transition: color 0.3s ease;
            text-align: left;
            font-family: 'G2ErikaMono', monospace;
            font-weight: normal;
            text-transform: uppercase;
        }

        body.dark .control-group label {
            color: #999;
        }

        .control-group input[type="range"] {
            width: 150px;
            height: 4px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 2px;
            outline: none;
            transition: all 0.3s ease;
            border: none;
        }

        body.dark .control-group input[type="range"] {
            background: #404040;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #000000;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        body.dark .control-group input[type="range"]::-webkit-slider-thumb {
            background: #FFFFFF;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .control-group span {
            text-align: right;
            font-size: 12px;
            color: #666;
            transition: color 0.3s ease;
            font-family: 'G2ErikaMono', monospace;
            font-weight: normal;
            text-transform: uppercase;
        }

        body.dark .control-group span {
            color: #999;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 10px;
            height: 10px;
            margin: 1px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e0e0e0;
            transition: all 0.3s ease;
            border-radius: 50%;
        }

        body.dark .slider {
            background-color: #404040;
        }

        input:checked+.slider {
            background-color: #000000;
        }

        body.dark input:checked+.slider {
            background-color: #FFFFFF;
        }

        .slider:hover {
            transform: scale(1.1);
        }

        .export-buttons {
            position: fixed;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 100;
            justify-content: flex-end;
        }

        .export-btn {
            background-color: #000000;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'G2ErikaMono', monospace;
            font-weight: normal;
            text-transform: uppercase;
        }

        .export-btn:hover {
            background-color: #333333;
            transform: translateY(-1px);
        }

        body.dark .export-btn {
            background-color: #FFFFFF;
            color: #000000;
        }

        body.dark .export-btn:hover {
            background-color: #CCCCCC;
        }

        .control-group select {
            width: 155px;
            height: 22px;
            background-color: #e0e0e0;
            border: none;
            border-radius: 4px;
            padding: 0 8px;
            font-size: 12px;
            color: #666;
            font-family: 'G2ErikaMono', monospace;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
            outline: none;
            font-weight: normal;
            text-transform: uppercase;
        }

        body.dark .control-group select {
            background-color: #404040;
            color: #999;
        }

        .control-group select:focus {
            background-color: #d0d0d0;
        }

        body.dark .control-group select:focus {
            background-color: #505050;
        }

        .type-btn {
            background-color: #e0e0e0;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #666;
            transition: all 0.3s ease;
            font-family: 'G2ErikaMono', monospace;
            font-weight: normal;
            text-transform: uppercase;
        }

        body.dark .type-btn {
            background-color: #404040;
            color: #999;
        }

        .type-btn:hover {
            background-color: #d0d0d0;
            transform: translateY(-1px);
        }

        body.dark .type-btn:hover {
            background-color: #505050;
        }

        .type-btn.active {
            background-color: #000000;
            color: white;
        }

        body.dark .type-btn.active {
            background-color: #FFFFFF;
            color: #000000;
        }

        .type-text {
            font-size: 12px;
            color: #666;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'G2ErikaMono', monospace;
            font-weight: normal;
            text-transform: uppercase;
        }

        body.dark .type-text {
            color: #999;
        }

        .type-text:hover {
            color: #000000;
        }

        body.dark .type-text:hover {
            color: #FFFFFF;
        }

        .type-text.active {
            color: #000000;
        }

        body.dark .type-text.active {
            color: #FFFFFF;
        }
    </style>
</head>

<body>
    <div class="container">
        <input type="text" id="textInput" placeholder="Type here..." value="SVG FONTS">
        <input type="text" id="textInput2" placeholder="Type second word..." value="MORPH ME">

        <div class="controls">
            <div class="control-section">
                <h3>Basics</h3>
                <div class="control-group">
                    <label for="fontSize">Size</label>
                    <input type="range" id="fontSize" min="50" max="1000" step="10" value="200">
                </div>
                <div class="control-group">
                    <label for="spacing">Space</label>
                    <input type="range" id="spacing" min="0.5" max="2" step="0.1" value="1">
                </div>
                <div class="control-group">
                    <label for="yOffset">Y-Off</label>
                    <input type="range" id="yOffset" min="-200" max="200" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="morphAmount">Morph</label>
                    <input type="range" id="morphAmount" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="morphSpeed">M-Speed</label>
                    <input type="range" id="morphSpeed" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="individualMorph">I-Morph</label>
                    <label class="switch">
                        <input type="checkbox" id="individualMorph">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="capsLock">Caps</label>
                    <label class="switch">
                        <input type="checkbox" id="capsLock" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="showMarkers">Markers</label>
                    <label class="switch">
                        <input type="checkbox" id="showMarkers" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group" style="display: flex; align-items: center; gap: 8px;">
                    <label style="flex: 0 0 50px;">Type</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label id="markerTypeDots" class="type-text active">Dots</label>
                        <label id="markerTypeCrosses" class="type-text">Crosses</label>
                        <label id="markerTypeHeart" class="type-text">Heart</label>
                        <label for="customMarker" class="type-text">
                            <input type="file" id="customMarker" accept=".svg" style="display: none;">
                            Custom
                        </label>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>Markers</h3>
                <div class="control-group">
                    <label for="dotDensity">Density</label>
                    <input type="range" id="dotDensity" min="1" max="50" step="0.1" value="45">
                </div>
                <div class="control-group">
                    <label for="dotSize">Size</label>
                    <input type="range" id="dotSize" min="1" max="50" step="0.5" value="2">
                </div>
                <div class="control-group">
                    <label for="crossThickness">Cross</label>
                    <input type="range" id="crossThickness" min="1" max="50" step="0.5" value="1">
                </div>
                <div class="control-group">
                    <label for="strokeWidth">Stroke</label>
                    <input type="range" id="strokeWidth" min="0.1" max="20" step="0.1" value="5">
                </div>
                <div class="control-group">
                    <label for="strokeJoin">S-Join</label>
                    <select id="strokeJoin">
                        <option value="round">Round</option>
                        <option value="miter">Miter</option>
                        <option value="bevel">Bevel</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="pathColor">P-Color</label>
                    <select id="pathColor">
                        <option value="black">Black</option>
                        <option value="white">White</option>
                        <option value="red">Red</option>
                        <option value="blue">Blue</option>
                        <option value="green">Green</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="pathZIndex">P-Z</label>
                    <label class="switch">
                        <input type="checkbox" id="pathZIndex" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="showPath">Path</label>
                    <label class="switch">
                        <input type="checkbox" id="showPath">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="rotate">Rotate</label>
                    <label class="switch">
                        <input type="checkbox" id="rotate">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="gradientFill">Gradient</label>
                    <label class="switch">
                        <input type="checkbox" id="gradientFill">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="invertGradient">Invert</label>
                    <label class="switch">
                        <input type="checkbox" id="invertGradient">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <div class="control-section">
                <h3>Grid</h3>
                <div class="control-group">
                    <label for="gridSize">Size</label>
                    <input type="range" id="gridSize" min="5" max="50" step="1" value="20">
                </div>
                <div class="control-group">
                    <label for="gridPull">Pull</label>
                    <input type="range" id="gridPull" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="showGrid">Show</label>
                    <label class="switch">
                        <input type="checkbox" id="showGrid">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="gridColor">Color</label>
                    <select id="gridColor">
                        <option value="black">Black</option>
                        <option value="white">White</option>
                        <option value="red">Red</option>
                        <option value="blue">Blue</option>
                        <option value="green">Green</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="gridStroke">Stroke</label>
                    <input type="range" id="gridStroke" min="0.1" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-group">
                    <label for="gridOffset">Offset</label>
                    <label class="switch">
                        <input type="checkbox" id="gridOffset" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <div class="control-section">
                <h3>Animation</h3>
                <div class="control-group">
                    <label for="animSpeed">Speed</label>
                    <input type="range" id="animSpeed" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="animColorSpeed">C-Speed</label>
                    <input type="range" id="animColorSpeed" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="animAmp">Amp</label>
                    <input type="range" id="animAmp" min="0" max="500" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="animType">Type</label>
                    <select id="animType">
                        <option value="wave">Wave</option>
                        <option value="pulse">Pulse</option>
                        <option value="spiral">Spiral</option>
                        <option value="bounce">Bounce</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="animPos">Pos</label>
                    <label class="switch">
                        <input type="checkbox" id="animPos" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="animColor">Color</label>
                    <label class="switch">
                        <input type="checkbox" id="animColor" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="animGridSize">Grid</label>
                    <input type="range" id="animGridSize" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="animGridPull">Pull</label>
                    <input type="range" id="animGridPull" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="animColorOffset">Color</label>
                    <input type="range" id="animColorOffset" min="0" max="100" step="1" value="0">
                </div>
            </div>

            <div class="control-section">
                <h3>Theme</h3>
                <div class="control-group">
                    <label for="colorMode">Color</label>
                    <label class="switch">
                        <input type="checkbox" id="colorMode">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="colorPalette">Palette</label>
                    <select id="colorPalette">
                        <option value="neon">Neon</option>
                        <option value="red">Red</option>
                        <option value="green">Green</option>
                        <option value="blue">Blue</option>
                        <option value="white">White</option>
                        <option value="black">Black</option>
                        <option value="pastel">Pastel</option>
                        <option value="nature">Nature</option>
                        <option value="mountains">Mountains</option>
                        <option value="beach">Beach</option>
                        <option value="mondrian">Mondrian</option>
                        <option value="sunset">Sunset</option>
                        <option value="ocean">Ocean</option>
                        <option value="forest">Forest</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="fire">Fire</option>
                        <option value="ice">Ice</option>
                        <option value="pink">Pink</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="colorCount">Colors</label>
                    <input type="range" id="colorCount" min="2" max="200" step="1" value="6">
                </div>
                <div class="control-group">
                    <label for="individualColors">C-Mode</label>
                    <label class="switch">
                        <input type="checkbox" id="individualColors">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="orderedColors">Ordered</label>
                    <label class="switch">
                        <input type="checkbox" id="orderedColors">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <label for="darkMode">Theme</label>
                    <label class="switch">
                        <input type="checkbox" id="darkMode">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <div id="svgContainer"></div>
    </div>

    <div class="export-buttons">
        <button id="exportStatic" class="export-btn">SVG</button>
        <button id="exportSettings" class="export-btn">LOG</button>
    </div>

    <script>
        let fontData = {};
        let charColors = {};
        const svgContainer = document.getElementById('svgContainer');
        const textInput = document.getElementById('textInput');
        const textInput2 = document.getElementById('textInput2');
        const fontSizeSlider = document.getElementById('fontSize');
        const dotDensitySlider = document.getElementById('dotDensity');
        const dotSizeSlider = document.getElementById('dotSize');
        const strokeWidthSlider = document.getElementById('strokeWidth');
        const showPathSwitch = document.getElementById('showPath');
        const capsLockSwitch = document.getElementById('capsLock');
        const colorModeSwitch = document.getElementById('colorMode');
        const crossThicknessSlider = document.getElementById('crossThickness');
        const rotateSwitch = document.getElementById('rotate');
        const spacingSlider = document.getElementById('spacing');
        const darkModeSwitch = document.getElementById('darkMode');
        const gridSizeSlider = document.getElementById('gridSize');
        const gridPullSlider = document.getElementById('gridPull');
        const animSpeedSlider = document.getElementById('animSpeed');
        const animColorSpeedSlider = document.getElementById('animColorSpeed');
        const animAmpSlider = document.getElementById('animAmp');
        const animTypeSelect = document.getElementById('animType');
        const animPosSwitch = document.getElementById('animPos');
        const animColorSwitch = document.getElementById('animColor');
        const animGridSizeSlider = document.getElementById('animGridSize');
        const animGridPullSlider = document.getElementById('animGridPull');
        const gradientFillSwitch = document.getElementById('gradientFill');
        const invertGradientSwitch = document.getElementById('invertGradient');
        const individualColorsSwitch = document.getElementById('individualColors');
        const orderedColorsSwitch = document.getElementById('orderedColors');
        const colorCountSlider = document.getElementById('colorCount');
        const customMarkerInput = document.getElementById('customMarker');
        const morphAmountSlider = document.getElementById('morphAmount');
        const individualMorphSwitch = document.getElementById('individualMorph');
        const morphSpeedSlider = document.getElementById('morphSpeed');
        const yOffsetSlider = document.getElementById('yOffset');
        const pathColorSelect = document.getElementById('pathColor');
        const pathZIndexSwitch = document.getElementById('pathZIndex');
        const showMarkersSwitch = document.getElementById('showMarkers');
        const strokeJoinSelect = document.getElementById('strokeJoin');
        const showGridSwitch = document.getElementById('showGrid');
        const gridColorSelect = document.getElementById('gridColor');
        const gridStrokeSlider = document.getElementById('gridStroke');
        const gridOffsetSwitch = document.getElementById('gridOffset');
        const animColorOffsetSlider = document.getElementById('animColorOffset');
        let customMarkerSVG = null;
        let animationFrame = null;
        let startTime = null;
        let morphAnimationFrame = null;
        let morphStartTime = null;
        let morphDirection = 1;

        const exportStaticBtn = document.getElementById('exportStatic');
        const exportSettingsBtn = document.getElementById('exportSettings');

        // Update display on input changes
        fontSizeSlider.addEventListener('input', updateDisplay);
        dotDensitySlider.addEventListener('input', updateDisplay);
        dotSizeSlider.addEventListener('input', updateDisplay);
        strokeWidthSlider.addEventListener('input', updateDisplay);
        showPathSwitch.addEventListener('change', updateDisplay);
        capsLockSwitch.addEventListener('change', updateDisplay);
        colorModeSwitch.addEventListener('change', () => {
            generateColors();
            updateDisplay();
        });
        crossThicknessSlider.addEventListener('input', updateDisplay);
        rotateSwitch.addEventListener('change', updateDisplay);
        spacingSlider.addEventListener('input', updateDisplay);
        darkModeSwitch.addEventListener('change', () => {
            document.body.classList.toggle('dark');
        });
        gridSizeSlider.addEventListener('input', updateDisplay);
        gridPullSlider.addEventListener('input', updateDisplay);
        showGridSwitch.addEventListener('change', updateDisplay);
        gridColorSelect.addEventListener('change', updateDisplay);
        gridStrokeSlider.addEventListener('input', updateDisplay);
        gridOffsetSwitch.addEventListener('change', updateDisplay);
        animSpeedSlider.addEventListener('input', () => {
            if (parseFloat(animSpeedSlider.value) === 0) {
                cancelAnimationFrame(animationFrame);
                updateDisplay();
            } else {
                startAnimation();
            }
        });
        animColorSpeedSlider.addEventListener('input', () => {
            if (parseFloat(animColorSpeedSlider.value) === 0) {
                cancelAnimationFrame(animationFrame);
                updateDisplay();
            } else {
                startAnimation();
            }
        });
        animAmpSlider.addEventListener('input', updateDisplay);
        animTypeSelect.addEventListener('change', updateDisplay);
        animPosSwitch.addEventListener('change', updateDisplay);
        animColorSwitch.addEventListener('change', updateDisplay);
        animGridSizeSlider.addEventListener('input', updateDisplay);
        animGridPullSlider.addEventListener('change', updateDisplay);
        gradientFillSwitch.addEventListener('change', updateDisplay);
        invertGradientSwitch.addEventListener('change', updateDisplay);
        individualColorsSwitch.addEventListener('change', () => {
            generateColors();
            updateDisplay();
        });
        orderedColorsSwitch.addEventListener('change', () => {
            generateColors();
            updateDisplay();
        });
        colorCountSlider.addEventListener('input', () => {
            generateColors();
            updateDisplay();
        });
        customMarkerInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(event.target.result, 'image/svg+xml');
                    customMarkerSVG = svgDoc.querySelector('svg');
                    markerType = 2;
                    updateMarkerTypeUI();
                    updateDisplay();
                };
                reader.readAsText(file);
            }
        });
        textInput2.addEventListener('input', (e) => {
            if (capsLockSwitch.checked) {
                textInput2.value = textInput2.value.toUpperCase();
            }
            generateColors();
            updateDisplay();
        });
        morphAmountSlider.addEventListener('input', updateDisplay);
        individualMorphSwitch.addEventListener('change', updateDisplay);
        morphSpeedSlider.addEventListener('input', () => {
            if (parseFloat(morphSpeedSlider.value) === 0) {
                cancelAnimationFrame(morphAnimationFrame);
            } else {
                startMorphAnimation();
            }
        });
        yOffsetSlider.addEventListener('input', updateDisplay);
        pathColorSelect.addEventListener('change', updateDisplay);
        pathZIndexSwitch.addEventListener('change', updateDisplay);
        showMarkersSwitch.addEventListener('change', updateDisplay);
        strokeJoinSelect.addEventListener('change', updateDisplay);

        // Handle text input with caps lock
        textInput.addEventListener('input', (e) => {
            if (capsLockSwitch.checked) {
                textInput.value = textInput.value.toUpperCase();
            }
            generateColors();
            updateDisplay();
        });

        function interpolateColor(color1, color2, factor) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);

            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function getEffectivePalette(palette, targetCount) {
            // If target count is less than or equal to palette length, use direct colors
            if (targetCount <= palette.length) {
                return palette.slice(0, targetCount);
            }
            
            // Only interpolate if we need more colors than the palette provides
            const effectivePalette = [];
            const steps = targetCount - 1;
            const segments = palette.length - 1;
            
            for (let i = 0; i < targetCount; i++) {
                const position = i / steps;
                const segmentIndex = Math.floor(position * segments);
                const segmentPosition = (position * segments) - segmentIndex;
                
                const color1 = palette[segmentIndex];
                const color2 = palette[(segmentIndex + 1) % palette.length];
                
                effectivePalette.push(interpolateColor(color1, color2, segmentPosition));
            }
            
            return effectivePalette;
        }

        function getRandomColor() {
            const palette = COLOR_PALETTES[colorPaletteSelect.value];
            const colorCount = parseInt(colorCountSlider.value);
            const colorOffset = parseFloat(animColorOffsetSlider.value) / 100;
            
            // If color count is less than or equal to palette length, use direct colors
            if (colorCount <= palette.length) {
                const offsetIndex = Math.floor(colorOffset * colorCount);
                return palette[(offsetIndex) % colorCount];
            }
            
            const effectivePalette = getEffectivePalette(palette, colorCount);
            
            if (orderedColorsSwitch.checked && individualColorsSwitch.checked) {
                const offsetIndex = Math.floor(colorOffset * effectivePalette.length);
                return effectivePalette[offsetIndex % effectivePalette.length];
            }
            return effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
        }

        function generateColors() {
            charColors = {};
            if (colorModeSwitch.checked) {
                Array.from(textInput.value).forEach(char => {
                    if (fontData[char]) {
                        if (individualColorsSwitch.checked) {
                            const points = getPointsAlongPath(fontData[char].path, parseFloat(dotDensitySlider.value));
                            charColors[char] = {};
                            const palette = COLOR_PALETTES[colorPaletteSelect.value];
                            const colorCount = parseInt(colorCountSlider.value);
                            const effectivePalette = getEffectivePalette(palette, colorCount);
                            const colorOffset = parseFloat(animColorOffsetSlider.value) / 100;

                            for (let i = 0; i < points.length; i++) {
                                if (orderedColorsSwitch.checked) {
                                    // Cycle through palette colors in order with offset
                                    const offsetIndex = Math.floor((i + colorOffset * effectivePalette.length) % effectivePalette.length);
                                    charColors[char][i] = effectivePalette[offsetIndex];
                                } else {
                                    charColors[char][i] = getRandomColor();
                                }
                            }
                        } else {
                            charColors[char] = getRandomColor();
                        }
                    }
                });
            }
        }

        // Load and parse the SVG font
        fetch('240415_Chesa.svg')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.text();
            })
            .then(svgText => {
                // Parse the SVG document
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

                // Find all glyph elements
                const glyphs = svgDoc.querySelectorAll('glyph');

                // Extract path data for each character
                glyphs.forEach(glyph => {
                    const unicode = glyph.getAttribute('unicode');
                    if (unicode && unicode.length === 1) {
                        const char = unicode;
                        const path = glyph.getAttribute('d');
                        const width = parseFloat(glyph.getAttribute('horiz-adv-x') || '1000');

                        if (path) {
                            fontData[char] = {
                                path: path,
                                width: width
                            };
                        }
                    }
                });

                generateColors();
                updateDisplay();
            })
            .catch(error => {
                console.error('Error loading SVG font:', error);
            });

        function getPointsAlongPath(path, spacing) {
            if (!path) return [];

            const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathElement.setAttribute('d', path);
            const length = pathElement.getTotalLength();

            // Invert and scale the spacing value for wider range
            const adjustedSpacing = (51 - spacing) * 20; // Convert from 0.1-50 to 1000-20
            const numPoints = Math.ceil(length / adjustedSpacing);
            const points = [];

            // Calculate the exact step size for even distribution
            const step = length / (numPoints - 1);

            // Get points at regular intervals
            for (let i = 0; i < numPoints; i++) {
                const point = pathElement.getPointAtLength(i * step);
                points.push(point);
            }

            return points;
        }

        const colorPaletteSelect = document.getElementById('colorPalette');

        colorPaletteSelect.addEventListener('change', () => {
            generateColors();
            updateDisplay();
        });

        const COLOR_PALETTES = {
            neon: [
                '#00ff00', // Neon Green
                '#ff00ff', // Neon Pink
                '#00ffff', // Neon Cyan
                '#ff0000', // Neon Red
                '#ffff00', // Neon Yellow
                '#ff8800', // Neon Orange
            ],
            pink: [
                '#FFC0CB', // Pink
                '#FFB6C1', // Light Pink
                '#FF69B4', // Hot Pink
                '#FF1493', // Deep Pink
                '#FF69B4', // Hot Pink
                '#FFB6C1', // Light Pink
                '#FFC0CB', // Pink
                '#FFB6C1', // Light Pink
                '#FF69B4', // Hot Pink
                '#FF1493', // Deep Pink
                '#FF69B4', // Hot Pink
                '#FFB6C1', // Light Pink
            ],
            red: [
                '#FF0000', // Pure Red
            ],
            green: [
                '#00FF00', // Pure Green
            ],
            blue: [
                '#0000FF', // Pure Blue
            ],
            white: [
                '#FFFFFF', // Pure White
            ],
            black: [
                '#000000', // Pure Black
                '#222222', // Dark Gray
                '#444444', // Medium Gray
                '#666666', // Light Gray
                '#888888', // Lighter Gray
            ],
            pastel: [
                '#FFB3BA', // Pastel Pink
                '#BAFFC9', // Pastel Green
                '#BAE1FF', // Pastel Blue
                '#FFFFBA', // Pastel Yellow
                '#FFB3FF', // Pastel Purple
                '#FFE4B5', // Pastel Orange
            ],
            nature: [
                '#2D5A27', // Forest Green
                '#8B4513', // Saddle Brown
                '#1E4D2B', // Dark Green
                '#A0522D', // Sienna
                '#006400', // Dark Green
                '#8FBC8F', // Dark Sea Green
            ],
            mountains: [
                '#2C3E50', // Dark Blue-Gray
                '#34495E', // Slate
                '#7F8C8D', // Gray
                '#95A5A6', // Light Gray
                '#BDC3C7', // Silver
                '#ECF0F1', // Clouds
                '#2C3E50', // Dark Blue-Gray
            ],
            beach: [
                '#1ABC9C', // Turquoise
                '#16A085', // Green Sea
                '#F1C40F', // Sunflower
                '#F39C12', // Orange
                '#E67E22', // Carrot
                '#D35400', // Pumpkin
                '#3498DB', // Peter River
            ],
            mondrian: [
                '#FF0000', // Red
                '#0000FF', // Blue
                '#FFFF00', // Yellow
                '#FFFFFF', // White
                '#000000', // Black
            ],
            sunset: [
                '#FF6B6B', // Coral
                '#FF8E53', // Peach
                '#FFB847', // Light Orange
                '#FFD93D', // Yellow
                '#FF6B6B', // Coral
            ],
            ocean: [
                '#1A237E', // Deep Blue
                '#0D47A1', // Blue
                '#1976D2', // Light Blue
                '#42A5F5', // Sky Blue
                '#90CAF9', // Pale Blue
                '#42A5F5', // Sky Blue
                '#1976D2', // Light Blue
                '#0D47A1', // Blue
                '#1A237E', // Deep Blue
            ],
            forest: [
                '#1B5E20', // Dark Green
                '#2E7D32', // Green
                '#388E3C', // Light Green
                '#4CAF50', // Bright Green
                '#81C784', // Pale Green
                '#4CAF50', // Bright Green
                '#388E3C', // Light Green
                '#2E7D32', // Green
                '#1B5E20', // Dark Green
            ],
            rainbow: [
                '#FF0000', // Red
                '#FF7F00', // Orange
                '#FFFF00', // Yellow
                '#00FF00', // Green
                '#0000FF', // Blue
                '#4B0082', // Indigo
                '#9400D3', // Violet
                '#4B0082', // Indigo
                '#0000FF', // Blue
                '#00FF00', // Green
                '#FFFF00', // Yellow
                '#FF7F00', // Orange
                '#FF0000', // Red
            ],
            fire: [
                '#FF0000', // Red
                '#FF4500', // Orange Red
                '#FF8C00', // Dark Orange
                '#FFA500', // Orange
                '#FFD700', // Gold
                '#FFA500', // Orange
                '#FF8C00', // Dark Orange
                '#FF4500', // Orange Red
                '#FF0000', // Red
            ],
            ice: [
                '#E3F2FD', // Lightest Blue
                '#BBDEFB', // Light Blue
                '#90CAF9', // Blue
                '#64B5F6', // Medium Blue
                '#42A5F5', // Dark Blue
                '#64B5F6', // Medium Blue
                '#90CAF9', // Blue
                '#BBDEFB', // Light Blue
                '#E3F2FD', // Lightest Blue
            ],
            heart: [
                '#FF0000', // Red
                '#FF69B4', // Hot Pink
                '#FF1493', // Deep Pink
                '#FFC0CB', // Pink
                '#FF69B4', // Hot Pink
                '#FF0000', // Red
            ],
        };

        function createMarker(x, y, size, isCross, color, crossThickness, rotate, pathAngle) {
            if (markerType === 3 && customMarkerSVG) {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                // Get the viewBox of the original SVG
                const viewBox = customMarkerSVG.getAttribute('viewBox');
                let width, height, viewBoxX, viewBoxY;

                if (viewBox) {
                    [viewBoxX, viewBoxY, width, height] = viewBox.split(' ').map(Number);
                } else {
                    // Fallback to bounding box if no viewBox
                    const bbox = customMarkerSVG.getBBox();
                    width = bbox.width;
                    height = bbox.height;
                    viewBoxX = bbox.x;
                    viewBoxY = bbox.y;
                }

                // Calculate center point of the viewBox
                const centerX = viewBoxX + width / 2;
                const centerY = viewBoxY + height / 2;

                // Calculate scale to fit the specified size
                const maxDimension = Math.max(width, height);
                const scale = size / maxDimension;

                // Create a new SVG element with the same viewBox
                const newSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                if (viewBox) newSvg.setAttribute('viewBox', viewBox);

                // Function to recursively process SVG elements
                const processElement = (element) => {
                    const newElement = document.createElementNS('http://www.w3.org/2000/svg', element.tagName);

                    // Copy all attributes
                    Array.from(element.attributes).forEach(attr => {
                        newElement.setAttribute(attr.name, attr.value);
                    });

                    // Set fill color or gradient for all elements except those with fill="none"
                    if (element.getAttribute('fill') !== 'none') {
                        if (gradientFillSwitch.checked) {
                            // Create a unique ID for the gradient
                            const gradientId = `gradient-${x}-${y}-${element.tagName}`;

                            // Create the gradient definition
                            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                            gradient.setAttribute('id', gradientId);
                            gradient.setAttribute('cx', '50%');
                            gradient.setAttribute('cy', '50%');
                            gradient.setAttribute('r', '50%');
                            gradient.setAttribute('fx', '50%');
                            gradient.setAttribute('fy', '50%');

                            // Add gradient stops
                            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stop1.setAttribute('offset', '0%');
                            stop1.setAttribute('stop-color', color);
                            stop1.setAttribute('stop-opacity', invertGradientSwitch.checked ? '0.3' : '1');

                            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stop2.setAttribute('offset', '100%');
                            stop2.setAttribute('stop-color', color);
                            stop2.setAttribute('stop-opacity', invertGradientSwitch.checked ? '1' : '0.3');

                            gradient.appendChild(stop1);
                            gradient.appendChild(stop2);

                            // Add gradient to defs
                            const defs = svgContainer.querySelector('svg defs');
                            defs.appendChild(gradient);

                            // Apply gradient to element
                            newElement.setAttribute('fill', `url(#${gradientId})`);
                        } else {
                            newElement.setAttribute('fill', color);
                        }
                    }

                    // Remove stroke attributes
                    newElement.removeAttribute('stroke');
                    newElement.removeAttribute('stroke-width');

                    // Process child elements
                    Array.from(element.children).forEach(child => {
                        newElement.appendChild(processElement(child));
                    });

                    return newElement;
                };

                // Process the original SVG
                const processedSvg = processElement(customMarkerSVG);
                newSvg.appendChild(processedSvg);

                // Set transform-box and transform-origin for proper centering
                newSvg.style.transformBox = 'fill-box';
                newSvg.setAttribute('transform-origin', 'center');

                // Set the transform on the group to position and scale, accounting for the center point
                group.setAttribute('transform', `translate(${x - centerX * scale},${y - centerY * scale}) scale(${scale})`);
                group.appendChild(newSvg);

                return group;
            } else if (markerType === 2) {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                // Create heart shape
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const scale = size / 20; // Scale the heart to match the size parameter
                
                // Heart path data
                path.setAttribute('d', `M${x},${y - 5 * scale} 
                    C${x - 5 * scale},${y - 10 * scale} 
                    ${x - 10 * scale},${y - 5 * scale} 
                    ${x - 10 * scale},${y} 
                    C${x - 10 * scale},${y + 5 * scale} 
                    ${x},${y + 10 * scale} 
                    ${x},${y + 10 * scale} 
                    C${x},${y + 10 * scale} 
                    ${x + 10 * scale},${y + 5 * scale} 
                    ${x + 10 * scale},${y} 
                    C${x + 10 * scale},${y - 5 * scale} 
                    ${x + 5 * scale},${y - 10 * scale} 
                    ${x},${y - 5 * scale} 
                    Z`);
                
                if (gradientFillSwitch.checked) {
                    // Create a unique ID for the gradient
                    const gradientId = `gradient-${x}-${y}-heart`;
    
                    // Create the gradient definition
                    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    gradient.setAttribute('cx', '50%');
                    gradient.setAttribute('cy', '50%');
                    gradient.setAttribute('r', '50%');
                    gradient.setAttribute('fx', '50%');
                    gradient.setAttribute('fy', '50%');
    
                    // Add gradient stops
                    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop1.setAttribute('offset', '0%');
                    stop1.setAttribute('stop-color', color);
                    stop1.setAttribute('stop-opacity', invertGradientSwitch.checked ? '0.3' : '1');
    
                    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop2.setAttribute('offset', '100%');
                    stop2.setAttribute('stop-color', color);
                    stop2.setAttribute('stop-opacity', invertGradientSwitch.checked ? '1' : '0.3');
    
                    gradient.appendChild(stop1);
                    gradient.appendChild(stop2);
    
                    // Add gradient to defs
                    const defs = svgContainer.querySelector('svg defs');
                    defs.appendChild(gradient);
    
                    // Apply gradient to path
                    path.setAttribute('fill', `url(#${gradientId})`);
                } else {
                    path.setAttribute('fill', color);
                }
                
                group.appendChild(path);
                return group;
            } else if (markerType === 1) {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                let rotation = 0;
                if (rotate) rotation = 45; // Default to 45 when rotate is true

                if (rotation !== 0) {
                    group.setAttribute('transform', `rotate(${rotation},${x},${y})`);
                }

                // Create horizontal line
                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line1.setAttribute('x1', x - size);
                line1.setAttribute('y1', y);
                line1.setAttribute('x2', x + size);
                line1.setAttribute('y2', y);
                line1.setAttribute('stroke', color);
                line1.setAttribute('stroke-width', crossThickness);

                // Create vertical line
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('x1', x);
                line2.setAttribute('y1', y - size);
                line2.setAttribute('x2', x);
                line2.setAttribute('y2', y + size);
                line2.setAttribute('stroke', color);
                line2.setAttribute('stroke-width', crossThickness);

                group.appendChild(line1);
                group.appendChild(line2);
                return group;
            } else {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', size);

                if (gradientFillSwitch.checked) {
                    // Create a unique ID for the gradient
                    const gradientId = `gradient-${x}-${y}`;

                    // Create the gradient definition
                    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    gradient.setAttribute('cx', '50%');
                    gradient.setAttribute('cy', '50%');
                    gradient.setAttribute('r', '50%');
                    gradient.setAttribute('fx', '50%');
                    gradient.setAttribute('fy', '50%');

                    // Add gradient stops
                    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop1.setAttribute('offset', '0%');
                    stop1.setAttribute('stop-color', color);
                    stop1.setAttribute('stop-opacity', invertGradientSwitch.checked ? '0.3' : '1');

                    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop2.setAttribute('offset', '100%');
                    stop2.setAttribute('stop-color', color);
                    stop2.setAttribute('stop-opacity', invertGradientSwitch.checked ? '1' : '0.3');

                    gradient.appendChild(stop1);
                    gradient.appendChild(stop2);

                    // Add gradient to defs
                    const defs = svgContainer.querySelector('svg defs');
                    defs.appendChild(gradient);

                    // Apply gradient to circle
                    circle.setAttribute('fill', `url(#${gradientId})`);
                } else {
                    circle.setAttribute('fill', color);
                }

                return circle;
            }
        }

        // Update the marker type state and event listeners
        let markerType = 0; // 0 = dots, 1 = crosses, 2 = heart, 3 = custom SVG
        const markerTypeDots = document.getElementById('markerTypeDots');
        const markerTypeCrosses = document.getElementById('markerTypeCrosses');
        const markerTypeHeart = document.getElementById('markerTypeHeart');
        const markerTypeCustom = document.querySelector('label[for="customMarker"]');

        function updateMarkerTypeUI() {
            markerTypeDots.classList.toggle('active', markerType === 0);
            markerTypeCrosses.classList.toggle('active', markerType === 1);
            markerTypeHeart.classList.toggle('active', markerType === 2);
            markerTypeCustom.classList.toggle('active', markerType === 3);
        }

        markerTypeDots.addEventListener('click', () => {
            markerType = 0;
            updateMarkerTypeUI();
            updateDisplay();
        });

        markerTypeCrosses.addEventListener('click', () => {
            markerType = 1;
            updateMarkerTypeUI();
            updateDisplay();
        });

        markerTypeHeart.addEventListener('click', () => {
            markerType = 2;
            updateMarkerTypeUI();
            updateDisplay();
        });

        markerTypeCustom.addEventListener('click', () => {
            if (customMarkerSVG) {
                markerType = 3;
                updateMarkerTypeUI();
                updateDisplay();
            }
        });

        customMarkerInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(event.target.result, 'image/svg+xml');
                    customMarkerSVG = svgDoc.querySelector('svg');
                    markerType = 2;
                    updateMarkerTypeUI();
                    updateDisplay();
                };
                reader.readAsText(file);
            }
        });

        // Initialize UI
        updateMarkerTypeUI();

        function snapToGrid(x, y, gridSize, pullStrength) {
            if (pullStrength === 0) return { x, y };

            const gridX = Math.round(x / gridSize) * gridSize;
            const gridY = Math.round(y / gridSize) * gridSize;

            // Calculate the pull based on strength (0-100)
            const pull = pullStrength / 100;

            return {
                x: x + (gridX - x) * pull,
                y: y + (gridY - y) * pull
            };
        }

        function startAnimation() {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            startTime = performance.now();
            animate();
        }

        function animate() {
            // Update color offset based on time
            if (parseFloat(animColorSpeedSlider.value) > 0 && animColorSwitch.checked) {
                const time = (performance.now() - startTime) / 1000;
                const speed = parseFloat(animColorSpeedSlider.value) / 50; // Reduced speed factor
                const colorOffset = (time * speed) % 1;
                animColorOffsetSlider.value = colorOffset * 100;
                generateColors();
            }
            updateDisplay();
            animationFrame = requestAnimationFrame(animate);
        }

        function getAnimationOffset(x, y, time, speed, amplitude, type) {
            if (speed === 0 || amplitude === 0) return { x: 0, y: 0 };

            const normalizedSpeed = speed / 10;
            const normalizedAmp = amplitude / 20; // Adjusted for larger amplitude range

            switch (type) {
                case 'wave':
                    // Wave animation with position-based phase offset
                    const phaseX = x * 0.02;
                    const phaseY = y * 0.02;
                    return {
                        x: Math.sin(time * normalizedSpeed + phaseX) * normalizedAmp,
                        y: Math.cos(time * normalizedSpeed + phaseY) * normalizedAmp
                    };

                case 'pulse':
                    // Pulse animation with position-based phase offset
                    const phase = (x + y) * 0.01;
                    const pulse = Math.sin(time * normalizedSpeed + phase) * normalizedAmp;
                    return {
                        x: pulse,
                        y: pulse
                    };

                case 'spiral':
                    // Spiral animation
                    const angle = time * normalizedSpeed + (x + y) * 0.01;
                    const radius = normalizedAmp * (1 + Math.sin(time * normalizedSpeed * 0.5) * 0.5);
                    return {
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    };

                case 'bounce':
                    // Bounce animation
                    const bounceX = Math.abs(Math.sin(time * normalizedSpeed + x * 0.01)) * normalizedAmp;
                    const bounceY = Math.abs(Math.sin(time * normalizedSpeed * 1.2 + y * 0.01)) * normalizedAmp;
                    return {
                        x: bounceX,
                        y: bounceY
                    };

                case 'random':
                    // Random but smooth movement
                    const randomX = Math.sin(time * normalizedSpeed + x * 0.01) *
                        Math.cos(time * normalizedSpeed * 0.7 + y * 0.01) * normalizedAmp;
                    const randomY = Math.cos(time * normalizedSpeed + y * 0.01) *
                        Math.sin(time * normalizedSpeed * 0.7 + x * 0.01) * normalizedAmp;
                    return {
                        x: randomX,
                        y: randomY
                    };

                default:
                    return { x: 0, y: 0 };
            }
        }

        function getAnimationRotation(time, speed) {
            if (speed === 0) return 0;
            const normalizedSpeed = speed / 10;
            return Math.sin(time * normalizedSpeed) * 30; // Rotate up to 30 degrees
        }

        function updateDisplay() {
            if (Object.keys(fontData).length === 0) return;

            // Clear previous content
            svgContainer.innerHTML = '';

            // Create a new SVG element
            const newSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            newSvg.setAttribute('width', '100%');
            newSvg.setAttribute('height', '100%');
            newSvg.setAttribute('viewBox', '0 0 1200 600');
            newSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

            // Create defs element for gradients if gradient fill is enabled
            if (gradientFillSwitch.checked) {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                newSvg.appendChild(defs);
            }

            svgContainer.appendChild(newSvg);

            // Calculate total width of both words
            let totalWidth1 = 0;
            let totalWidth2 = 0;

            Array.from(textInput.value).forEach(char => {
                if (char === ' ') {
                    totalWidth1 += 200 * parseFloat(fontSizeSlider.value) / 1000 * parseFloat(spacingSlider.value);
                } else if (fontData[char]) {
                    totalWidth1 += fontData[char].width * parseFloat(fontSizeSlider.value) / 1000 * parseFloat(spacingSlider.value);
                }
            });

            Array.from(textInput2.value).forEach(char => {
                if (char === ' ') {
                    totalWidth2 += 200 * parseFloat(fontSizeSlider.value) / 1000 * parseFloat(spacingSlider.value);
                } else if (fontData[char]) {
                    totalWidth2 += fontData[char].width * parseFloat(fontSizeSlider.value) / 1000 * parseFloat(spacingSlider.value);
                }
            });

            // Calculate center positions for both words
            const centerX1 = 600 - (totalWidth1 / 2);
            const centerX2 = 600 - (totalWidth2 / 2);
            const y = 300 + parseFloat(yOffsetSlider.value); // Add Y-offset to center Y position
            const fontSize = parseFloat(fontSizeSlider.value);
            const scale = fontSize / 1000;
            const dotSpacing = parseFloat(dotDensitySlider.value);
            const dotSize = parseFloat(dotSizeSlider.value);
            const strokeWidth = parseFloat(strokeWidthSlider.value);
            const isCross = markerType === 1;
            const showPath = showPathSwitch.checked;
            const isRGB = colorModeSwitch.checked;
            const crossThickness = parseFloat(crossThicknessSlider.value);
            const rotate = rotateSwitch.checked;
            let gridSize = parseFloat(gridSizeSlider.value);
            let gridPull = parseFloat(gridPullSlider.value);
            const animSpeed = parseFloat(animSpeedSlider.value);
            const animAmp = parseFloat(animAmpSlider.value);
            const animationType = animTypeSelect.value;
            const animPos = animPosSwitch.checked;
            const animGridSize = animGridSizeSlider.value > 0;
            const animGridPull = animGridPullSlider.value > 0;
            const time = startTime ? (performance.now() - startTime) / 1000 : 0;
            const morphAmount = parseFloat(morphAmountSlider.value) / 100;

            // Create morphed points
            const morphedPoints = [];

            if (individualMorphSwitch.checked && textInput.value.length === textInput2.value.length) {
                // Individual letter morphing
                let currentPoints1 = [];
                let currentPoints2 = [];

                // Split points into letters for first word
                let currentX1 = centerX1;
                Array.from(textInput.value).forEach(char => {
                    if (char === ' ') {
                        currentX1 += 200 * scale * parseFloat(spacingSlider.value);
                    } else if (fontData[char]) {
                        const charWidth = fontData[char].width * scale * parseFloat(spacingSlider.value);
                        const charPoints = getPointsAlongPath(fontData[char].path, dotSpacing);
                        currentPoints1.push({
                            points: charPoints.map(p => ({
                                x: currentX1 + p.x * scale,
                                y: y - p.y * scale
                            })),
                            width: charWidth,
                            char: char
                        });
                        currentX1 += charWidth;
                    }
                });

                // Split points into letters for second word
                let currentX2 = centerX2;
                Array.from(textInput2.value).forEach(char => {
                    if (char === ' ') {
                        currentX2 += 200 * scale * parseFloat(spacingSlider.value);
                    } else if (fontData[char]) {
                        const charWidth = fontData[char].width * scale * parseFloat(spacingSlider.value);
                        const charPoints = getPointsAlongPath(fontData[char].path, dotSpacing);
                        currentPoints2.push({
                            points: charPoints.map(p => ({
                                x: currentX2 + p.x * scale,
                                y: y - p.y * scale
                            })),
                            width: charWidth,
                            char: char
                        });
                        currentX2 += charWidth;
                    }
                });

                // Only proceed with morphing if we have points in both words
                if (currentPoints1.length > 0 && currentPoints2.length > 0) {
                    // Morph each letter individually
                    for (let i = 0; i < currentPoints1.length; i++) {
                        const letter1 = currentPoints1[i];
                        const letter2 = currentPoints2[i];

                        // Calculate individual letter morph amount based on position
                        const letterProgress = i / currentPoints1.length;
                        const staggerAmount = 0.3;
                        const letterMorphAmount = Math.max(0, Math.min(1,
                            (morphAmount - letterProgress * staggerAmount) / (1 - staggerAmount)
                        ));

                        // Ensure both letters have the same number of points
                        const maxPoints = Math.max(letter1.points.length, letter2.points.length);

                        for (let j = 0; j < maxPoints; j++) {
                            const point1 = letter1.points[j % letter1.points.length];
                            const point2 = letter2.points[j % letter2.points.length];

                            let dotColor = 'black';
                            if (isRGB) {
                                if (individualColorsSwitch.checked) {
                                    const pointIndex = j % letter1.points.length;
                                    if (charColors[letter1.char] && charColors[letter1.char][pointIndex]) {
                                        dotColor = charColors[letter1.char][pointIndex];
                                    } else {
                                        dotColor = charColors[letter1.char] || 'black';
                                    }
                                } else {
                                    dotColor = charColors[letter1.char] || 'black';
                                }
                            }

                            morphedPoints.push({
                                x: point1.x + (point2.x - point1.x) * letterMorphAmount,
                                y: point1.y + (point2.y - point1.y) * letterMorphAmount,
                                color: dotColor
                            });
                        }
                    }
                }
            } else {
                // Regular morphing
                let x1 = centerX1;
                let x2 = centerX2;

                // Get points for both words
                const points1 = [];
                const points2 = [];

                // Collect points for first word
                Array.from(textInput.value).forEach(char => {
                    if (char === ' ') {
                        x1 += 200 * scale * parseFloat(spacingSlider.value);
                    } else if (fontData[char]) {
                        const charWidth = fontData[char].width * scale * parseFloat(spacingSlider.value);
                        const charPoints = getPointsAlongPath(fontData[char].path, dotSpacing);
                        charPoints.forEach((point, pointIndex) => {
                            points1.push({
                                x: x1 + point.x * scale,
                                y: y - point.y * scale,
                                char: char,
                                pointIndex: pointIndex
                            });
                        });
                        x1 += charWidth;
                    }
                });

                // Collect points for second word
                Array.from(textInput2.value).forEach(char => {
                    if (char === ' ') {
                        x2 += 200 * scale * parseFloat(spacingSlider.value);
                    } else if (fontData[char]) {
                        const charWidth = fontData[char].width * scale * parseFloat(spacingSlider.value);
                        const charPoints = getPointsAlongPath(fontData[char].path, dotSpacing);
                        charPoints.forEach(point => {
                            points2.push({
                                x: x2 + point.x * scale,
                                y: y - point.y * scale
                            });
                        });
                        x2 += charWidth;
                    }
                });

                // Only proceed with morphing if we have points in both words
                if (points1.length > 0 && points2.length > 0) {
                    // Regular morphing
                    const maxPoints = Math.max(points1.length, points2.length);

                    for (let i = 0; i < maxPoints; i++) {
                        const point1 = points1[i % points1.length];
                        const point2 = points2[i % points2.length];

                        let dotColor = 'black';
                        if (isRGB) {
                            if (individualColorsSwitch.checked) {
                                if (charColors[point1.char] && charColors[point1.char][point1.pointIndex]) {
                                    dotColor = charColors[point1.char][point1.pointIndex];
                                } else {
                                    dotColor = charColors[point1.char] || 'black';
                                }
                            } else {
                                dotColor = charColors[point1.char] || 'black';
                            }
                        }

                        morphedPoints.push({
                            x: point1.x + (point2.x - point1.x) * morphAmount,
                            y: point1.y + (point2.y - point1.y) * morphAmount,
                            color: dotColor
                        });
                    }
                }
            }

            // Get path color
            let pathColor = 'black';
            switch (pathColorSelect.value) {
                case 'white':
                    pathColor = '#FFFFFF';
                    break;
                case 'red':
                    pathColor = '#FF0000';
                    break;
                case 'blue':
                    pathColor = '#0000FF';
                    break;
                case 'green':
                    pathColor = '#00FF00';
                    break;
                default:
                    pathColor = '#000000';
            }

            // Create markers for morphed points
            if (showMarkersSwitch.checked) {
                morphedPoints.forEach((point, index) => {
                    let dotX = point.x;
                    let dotY = point.y;

                    // Calculate path angle for rotation if needed
                    let pathAngle = 0;
                    if (rotate) {
                        const nextPoint = morphedPoints[(index + 1) % morphedPoints.length];
                        const dx = nextPoint.x - point.x;
                        const dy = nextPoint.y - point.y;
                        pathAngle = Math.atan2(dy, dx) * (180 / Math.PI);
                    }

                    // Apply grid snapping if pull strength > 0
                    if (gridPull > 0) {
                        const snapped = snapToGrid(dotX, dotY, gridSize, gridPull);
                        dotX = snapped.x;
                        dotY = snapped.y;
                    }

                    // Apply position animation if enabled
                    if (animPos && animSpeed > 0) {
                        const animOffset = getAnimationOffset(dotX, dotY, time, animSpeed, animAmp, animationType);
                        dotX += animOffset.x;
                        dotY += animOffset.y;
                    }

                    const marker = createMarker(dotX, dotY, dotSize, isCross, point.color, crossThickness, rotate, pathAngle);
                    newSvg.appendChild(marker);
                });
            }

            // Create path if showPath is enabled
            if (showPathSwitch.checked) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let pathData = '';
                let currentLetterPoints = [];
                let currentLetter = null;

                morphedPoints.forEach((point, index) => {
                    let x = point.x;
                    let y = point.y;

                    // Apply grid snapping if needed
                    if (gridPull > 0) {
                        const snapped = snapToGrid(x, y, gridSize, gridPull);
                        x = snapped.x;
                        y = snapped.y;
                    }

                    // Apply animation if needed
                    if (animPos && animSpeed > 0) {
                        const animOffset = getAnimationOffset(x, y, time, animSpeed, animAmp, animationType);
                        x += animOffset.x;
                        y += animOffset.y;
                    }

                    // Check if we're starting a new letter
                    if (point.char !== currentLetter) {
                        // If we have points from the previous letter, add them to the path
                        if (currentLetterPoints.length > 0) {
                            pathData += currentLetterPoints.map((p, i) => 
                                `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`
                            ).join('');
                        }
                        // Start new letter
                        currentLetter = point.char;
                        currentLetterPoints = [];
                    }

                    // Add point to current letter's points
                    currentLetterPoints.push({ x, y });
                });

                // Add the last letter's points
                if (currentLetterPoints.length > 0) {
                    pathData += currentLetterPoints.map((p, i) => 
                        `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`
                    ).join('');
                }

                path.setAttribute('d', pathData);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', pathColor);
                path.setAttribute('stroke-width', strokeWidthSlider.value);
                path.setAttribute('stroke-linejoin', strokeJoinSelect.value);

                // Add path to SVG based on z-index setting
                if (pathZIndexSwitch.checked) {
                    // Path in front
                    newSvg.appendChild(path);
                } else {
                    // Path behind
                    newSvg.insertBefore(path, newSvg.firstChild);
                }
            }

            // Create grid if showGrid is enabled
            if (showGridSwitch.checked) {
                const grid = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Get grid color
                let gridColor = 'black';
                switch (gridColorSelect.value) {
                    case 'white':
                        gridColor = '#FFFFFF';
                        break;
                    case 'red':
                        gridColor = '#FF0000';
                        break;
                    case 'blue':
                        gridColor = '#0000FF';
                        break;
                    case 'green':
                        gridColor = '#00FF00';
                        break;
                    default:
                        gridColor = '#000000';
                }

                const gridStroke = parseFloat(gridStrokeSlider.value);
                const width = 1200;
                const height = 600;
                const padding = gridStroke;
                const offset = gridOffsetSwitch.checked ? gridSize / 2 : 0;

                // Create vertical lines
                for (let x = -padding - offset; x <= width + padding + offset; x += gridSize) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', 0);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', height);
                    line.setAttribute('stroke', gridColor);
                    line.setAttribute('stroke-width', gridStroke);
                    grid.appendChild(line);
                }

                // Create horizontal lines
                for (let y = -padding - offset; y <= height + padding + offset; y += gridSize) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', width);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', gridColor);
                    line.setAttribute('stroke-width', gridStroke);
                    grid.appendChild(line);
                }

                // Add grid to SVG
                newSvg.insertBefore(grid, newSvg.firstChild);
            }
        }

        // Initialize animation if speed is not zero
        if (parseFloat(animSpeedSlider.value) > 0) {
            startAnimation();
        }

        // Set default values
        darkModeSwitch.checked = false;
        document.body.classList.remove('dark');

        colorModeSwitch.checked = true;

        function downloadSVG(svgString, filename) {
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getCurrentSVG() {
            const svg = svgContainer.querySelector('svg');
            // Create a clone of the SVG to avoid affecting the display
            const exportSvg = svg.cloneNode(true);
            
            // Add timestamp to SVG
            const timestamp = new Date().toISOString();
            const comment = document.createComment(` Generated on ${timestamp} `);
            exportSvg.insertBefore(comment, exportSvg.firstChild);
            
            // Add viewBox and preserveAspectRatio attributes for better compatibility
            exportSvg.setAttribute('width', '1200');
            exportSvg.setAttribute('height', '600');
            exportSvg.setAttribute('viewBox', '0 0 1200 600');
            exportSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            exportSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            exportSvg.setAttribute('version', '1.1');
            
            return exportSvg ? exportSvg.outerHTML : '';
        }

        function getCurrentSettings() {
            const settings = {
                text: {
                    firstWord: textInput.value,
                    secondWord: textInput2.value,
                    fontSize: fontSizeSlider.value,
                    spacing: spacingSlider.value,
                    yOffset: yOffsetSlider.value,
                    capsLock: capsLockSwitch.checked,
                },
                markers: {
                    density: dotDensitySlider.value,
                    size: dotSizeSlider.value,
                    crossThickness: crossThicknessSlider.value,
                    strokeWidth: strokeWidthSlider.value,
                    strokeJoin: strokeJoinSelect.value,
                    pathColor: pathColorSelect.value,
                    pathZIndex: pathZIndexSwitch.checked,
                    showPath: showPathSwitch.checked,
                    showMarkers: showMarkersSwitch.checked,
                    markerType: markerType,
                },
                grid: {
                    size: gridSizeSlider.value,
                    pull: gridPullSlider.value,
                    show: showGridSwitch.checked,
                    color: gridColorSelect.value,
                    stroke: gridStrokeSlider.value,
                    offset: gridOffsetSwitch.checked,
                },
                animation: {
                    speed: animSpeedSlider.value,
                    amplitude: animAmpSlider.value,
                    type: animTypeSelect.value,
                    position: animPosSwitch.checked,
                    gridSize: animGridSizeSlider.value,
                    gridPull: animGridPullSlider.value,
                    colorOffset: animColorOffsetSlider.value,
                },
                theme: {
                    colorMode: colorModeSwitch.checked,
                    palette: colorPaletteSelect.value,
                    colorCount: colorCountSlider.value,
                    individualColors: individualColorsSwitch.checked,
                    orderedColors: orderedColorsSwitch.checked,
                    darkMode: darkModeSwitch.checked,
                },
                morph: {
                    amount: morphAmountSlider.value,
                    individual: individualMorphSwitch.checked,
                    speed: morphSpeedSlider.value,
                }
            };
            return JSON.stringify(settings, null, 2);
        }

        function downloadSettings(settingsString, filename) {
            const blob = new Blob([settingsString], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        exportStaticBtn.addEventListener('click', () => {
            const svgString = getCurrentSVG();
            if (svgString) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                downloadSVG(svgString, `svg-export-${timestamp}.svg`);
            }
        });

        exportSettingsBtn.addEventListener('click', () => {
            const settingsString = getCurrentSettings();
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            downloadSettings(settingsString, `settings-${timestamp}.json`);
        });

        // Update colors when density changes
        dotDensitySlider.addEventListener('input', () => {
            if (colorModeSwitch.checked && individualColorsSwitch.checked) {
                generateColors();
            }
            updateDisplay();
        });

        function startMorphAnimation() {
            if (morphAnimationFrame) {
                cancelAnimationFrame(morphAnimationFrame);
            }
            morphStartTime = performance.now();
            animateMorph();
        }

        function animateMorph() {
            // Use exponential scaling for speed to make higher values more dramatic
            const rawSpeed = parseFloat(morphSpeedSlider.value);
            const speed = Math.pow(rawSpeed / 50, 2) * 2; // Faster at higher values

            const time = (performance.now() - morphStartTime) / 1000;

            // Calculate morph amount using sine wave
            const morphAmount = (Math.sin(time * speed * Math.PI) + 1) / 2;

            // Update the morph slider value
            morphAmountSlider.value = morphAmount * 100;

            // Update the display
            updateDisplay();

            // Continue animation
            morphAnimationFrame = requestAnimationFrame(animateMorph);
        }

        // Update display on input changes
        animGridSizeSlider.addEventListener('input', updateDisplay);
        animGridPullSlider.addEventListener('change', updateDisplay);
        animColorOffsetSlider.addEventListener('input', () => {
            generateColors();
            updateDisplay();
        });

        // Update display on input changes
        animColorSwitch.addEventListener('change', updateDisplay);
        animColorSpeedSlider.addEventListener('input', () => {
            if (parseFloat(animColorSpeedSlider.value) === 0) {
                cancelAnimationFrame(animationFrame);
                updateDisplay();
            } else {
                startAnimation();
            }
        });
    </script>
</body>

</html>